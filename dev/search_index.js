var documenterSearchIndex = {"docs":
[{"location":"api/#API-overview","page":"API overview","title":"API overview","text":"","category":"section"},{"location":"api/","page":"API overview","title":"API overview","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    ConcurrentUtils;\n    signature = :strip_namespace,\n    include = api -> api.hasdoc && !(api.value isa Module),\n)","category":"page"},{"location":"#ConcurrentUtils.jl","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"","category":"section"},{"location":"#Promise","page":"ConcurrentUtils.jl","title":"Promise","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        Promise,\n        try_race_fetch,\n        try_race_fetch_or!,\n        race_fetch_or!,\n        try_race_put!,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"Promise\ntry_race_fetch\ntry_race_fetch_or!\nrace_fetch_or!\ntry_race_put!","category":"page"},{"location":"#ConcurrentUtils.Promise","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.Promise","text":"Promise{T}()\nPromise()\n\nCreate a promise of type T; i.e., a memory location that holds a value of type T that can be set once and retrieved asynchronously.\n\nExtended help\n\nFor an explanation on the concept, see: Futures and promises - Wikipedia.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch(p)\nTry.Err: NotSetError()\n\njulia> put!(p, 123);\n\njulia> fetch(p)\n123\n\njulia> try_race_put!(p, 456)\nTry.Err: OccupiedError{Int64}(123)\n\nMemory ordering\n\nAn event that retrieves or waits for a value from a promise establishes a happened-before edge from the event that have set the value to the promise.  Invocations of the API that includes an event that sets a value to a promise include:\n\nput!(promise, value) that does not throw.\ntry_race_put!(promise, value) that returns an Ok result.\ntry_race_fetch_or!(thunk, promise) that calls thunk (and hance returns an Err).\nrace_fetch_or!(thunk, promise) that calls thunk.\n\n(The invocation thunk() is sequenced-before the event that sets the value.)\n\nInvocations of the API that includes an event that retrieves or waits for a value from a promise include:\n\nfetch(promise)\nwait(promise)\ntry_race_fetch(promise) that returns an Ok result.\ntry_race_fetch_or!(thunk, promise) that does not call thunk (and hance returns an Ok)\nrace_fetch_or!(thunk, promise) that does not call thunk\n\nSupported operations\n\nA promise::Promise{T} supports the following operations:\n\nput!(promise, value): Set a value; throws an error if some value has already been set.\ntry_race_put!(promise, value): Try to set a value.\nfetch(promise): Obtain a value that the promise holds. Wait if necessary.\nwait(promise): Wait for a value to be set.\ntry_race_fetch(promise): Try to obtain an existing value in the promise.\ntry_race_fetch_or!(thunk, promise): Try to get a value or set a value generated by thunk.\nrace_fetch_or!(thunk, promise): Similar to try_race_fetch_or! but  the returned value does not indicate if thunk is called or not.\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.try_race_fetch","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_fetch","text":"try_race_fetch(promiselike) -> Ok(value::T) or Err(NotSetError())\n\nTry to retrieve a value if it is already set.  Return Ok(value) on success and Err(NotSetError()) on failure.\n\ntry_race_fetch can be called on a Promise or a tasklet (@tasklet).\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch(p)\nTry.Err: NotSetError()\n\njulia> put!(p, 123);\n\njulia> try_race_fetch(p)\nTry.Ok: 123\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.try_race_fetch_or!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_fetch_or!","text":"try_race_fetch_or!(thunk, promise::Promise{T}) -> Ok(existing::T) or Err(computed::T)\n\nFetch an existing value or set a computed value (computed = thunk()).  The thunk is called at most once for each instance of promise.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch_or!(p) do\n           123 + 456\n       end\nTry.Err: 579\n\njulia> try_race_fetch_or!(p) do\n           42\n       end\nTry.Ok: 579\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.race_fetch_or!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.race_fetch_or!","text":"race_fetch_or!(thunk, promise::Promise{T}) -> value::T\n\nFetch an existing value or set value = thunk().  The thunk is called at most once for each instance of promise.\n\nThis is similar to try_race_fetch_or! but the caller cannot tell if thunk is called or not by the return type.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> race_fetch_or!(p) do\n           println(\"called\")\n           123 + 456\n       end\ncalled\n579\n\njulia> race_fetch_or!(p) do\n           println(\"called\")\n           42\n       end\n579\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.try_race_put!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_put!","text":"try_race_put!(promise::Promise{T}, value) -> Ok(value′::T) or Err(OccupiedError(existing::T))\n\nTry to set a value in the promise.\n\nSince the value is converted to T first, the returned value′ may not be identical to the input value.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_put!(p, 123)\nTry.Ok: 123\n\njulia> try_race_put!(p, 456)\nTry.Err: OccupiedError{Int64}(123)\n\n\n\n\n\n","category":"function"},{"location":"#Promise-like-interfaces","page":"ConcurrentUtils.jl","title":"Promise-like interfaces","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        var\"@tasklet\",\n        var\"@once\",\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"@tasklet\n@once","category":"page"},{"location":"#ConcurrentUtils.@tasklet","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.@tasklet","text":"@tasklet code\n\nCreate an object that is a memoized version of () -> code but also acts like a Promise that is not settable.\n\nA t = @tasklet code supports: t(), fetch(t), wait(t), and try_race_fetch.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> t = @tasklet begin\n           println(\"called\")\n           123\n       end;\n\njulia> try_race_fetch(t)\nTry.Err: NotSetError()\n\njulia> t()\ncalled\n123\n\njulia> t()\n123\n\njulia> fetch(t)\n123\n\njulia> wait(t);\n\nMemory ordering\n\nAn event that retrieves or waits for a value from a tasklet t establishes a happened-before edge from the events in code.  Invocations of the API that includes an event that retrieves or waits for a value from a promise include:\n\nfetch(t)\nwait(t)\ntry_race_fetch(t) that returns an Ok result.\n\nSupported operations\n\nA tasklet t = @tasklet code supports the following operations:\n\nt(): Evaluate code if it hasn't been evaluated. Otherwise, equivalent to fetch.\nfetch(t): Wait for other tasks to invoke t() and then return the result.\nwait(t): Wait for other tasks to invoke t().\ntry_race_fetch: Try to retrieve the result of t() if it is already called.\n\n\n\n\n\n","category":"macro"},{"location":"#ConcurrentUtils.@once","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.@once","text":"@once code\n\nExecute code at most once within the lifetime of the Julia process.  It evaluates to the result of the first evaluation whenever the same location of the code is evaluated later.\n\nNote that code does not have access to the local variables.\n\nMemory ordering\n\nEvents that follow the run-time (as opposed to macro expansion-time) evaluation of @once code in the same Julia task have happened-before edge from the events in code.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> f() = @once Ref(123);\n\njulia> f() isa Ref\ntrue\n\njulia> f()[]\n123\n\nRef(123) is evaluated once and the identical Ref object is reused whenever f is called in this Julia process:\n\njulia> f() === f()\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"#Locks","page":"ConcurrentUtils.jl","title":"Locks","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        read_write_lock,\n        Backoff,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"read_write_lock\nBackoff","category":"page"},{"location":"#ConcurrentUtils.read_write_lock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.read_write_lock","text":"read_write_lock() -> (rlock, wlock)\n\nReturn the read handle rlock and the write handle wlock of a read-write lock.\n\nExtended help\n\nSupported operations:\n\nlock(rlock)\ntrylock(rlock) (not very efficient but lock-free)\nunlock(rlock)\nlock(wlock)\ntrylock(wlock)\nunlock(wlock)\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.Backoff","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.Backoff","text":"Backoff(mindelay, maxdelay) -> backoff\n\nCreate a callable backoff where backoff() spin-wait some amount of times.\n\nThe number of maximum calls to spinloop starts at mindelay and exponentially increases up to maxdelay.  backoff() returns the number of spinloop called.\n\nBackoff uses an internal RNG and it does not consume the default task-local RNG.\n\nExtended help\n\nExamples\n\nIf islocked does not cause data races, Backoff can be used to implement a backoff lock.\n\njulia> using ConcurrentUtils\n\njulia> function trylock_with_backoff(lck; nspins = 1000, mindelay = 1, maxdelay = 1000)\n           backoff = Backoff(mindelay, maxdelay)\n           n = 0\n           while true\n               while islocked(lck)\n                   spinloop()\n                   n += 1\n                   n > nspins && return false\n               end\n               trylock(lck) && return true\n               n += backoff()\n           end\n       end;\n\njulia> lck = ReentrantLock();\n\njulia> trylock_with_backoff(lck)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Guards","page":"ConcurrentUtils.jl","title":"Guards","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        Guard,\n        ReadWriteGuard,\n        guarding,\n        guarding_read,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"Guard\nReadWriteGuard\nguarding\nguarding_read","category":"page"},{"location":"#ConcurrentUtils.Guard","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.Guard","text":"Guard(data)\n\nGuard mutable data.  Use guarding to obtain exclusive access to data.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> guard = Guard(Ref(0));\n\njulia> guarding(guard) do ref\n           ref[] += 1\n       end\n1\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.ReadWriteGuard","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.ReadWriteGuard","text":"ReadWriteGuard(data)\n\nGuard mutable data.  Use guarding and guarding_read to obtain exclusive (\"write\") and shared (\"read\") access to data.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> guard = ReadWriteGuard(Ref(0));\n\njulia> guarding(guard) do ref\n           ref[] += 1\n       end\n1\n\njulia> guarding_read(guard) do ref\n           ref[]  # must not mutate anything\n       end\n1\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.guarding","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.guarding","text":"guarding(f!, guard)\n\nApply f! to the data wrapped in guard while obtaining exclusive access.\n\nSee: Guard, ReadWriteGuard, guarding_read\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> guard = Guard(Ref(0));\n\njulia> guarding(guard) do ref\n           ref[] += 1\n       end\n1\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.guarding_read","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.guarding_read","text":"guarding_read(f, guard)\n\nApply f to the data wrapped in guard while obtaining shared access.\n\nSee: Guard, ReadWriteGuard, guarding\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> guard = ReadWriteGuard(Ref(0));\n\njulia> guarding_read(guard) do ref\n           ref[]  # must not mutate anything\n       end\n0\n\n\n\n\n\n","category":"function"},{"location":"#Low-level-interfaces","page":"ConcurrentUtils.jl","title":"Low-level interfaces","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        ThreadLocalStorage,\n        spinloop,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"ThreadLocalStorage\nspinloop","category":"page"},{"location":"#ConcurrentUtils.ThreadLocalStorage","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.ThreadLocalStorage","text":"ThreadLocalStorage{T}(factory)\nThreadLocalStorage(factory)\n\nCreate a thread-local storage of type T created by factory().\n\nAn instance tls of ThreadLocalStorage support the operation x = tls[] for obtaining an object x of value T.\n\nwarning: Warning\nUsing this API is extremely tricky.  Arguably, it is not even well-defined when and how it can be used.Theoretically, it is safe to use this API if the programmer can ensure that, once a value x = tls[] is obtained, the code does not hit any yield points until there is no more access to x.  However, it is not possible to know if a certain operation is yield-free in general.Thus, this API currently exists primarily for helping migration of code written using nthreads and threadid in an ad-hoc manner.\n\nAn object of type T is allocated for each worker thread of the Julia runtime.  If T is not given, T = typeof(factory()) is used (i.e., factory is assumed to be type-stable).\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> tls = ThreadLocalStorage(Ref{Int});\n\njulia> tls[] isa Ref{Int}\ntrue\n\njulia> tls[][] = 123;\n\njulia> tls[][]\n123\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.spinloop","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.spinloop","text":"spinloop()\n\nA hint to the compiler, runtime, and hardware that spinloop() is in the middle of a spin loop.  Call this in a spin loop that requires some other worker threads to make forward progress in order for the current thread to make forward progress.\n\nwarning: Warning\nObserve that the above sentence specifically mentions worker threads and not Tasks.  A Julia programmer should always be alarmed whenever an API talks about threads instead of Tasks.  Prefer higher-level APIs such as channels and condition variables.A proper use of spinloop requires extra cares such as a fallback that waits in the Julia scheduler and/or a mechanism that enables the spin loop code path given that other threads exist and a task that can break the spin loop is running or will be scheduled eventually.\n\nImplementation detail\n\nIt calls GC.safepoint() and jl_cpu_pause.\n\n\n\n\n\n","category":"function"}]
}
