var documenterSearchIndex = {"docs":
[{"location":"api/#API-overview","page":"API overview","title":"API overview","text":"","category":"section"},{"location":"api/","page":"API overview","title":"API overview","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    ConcurrentUtils;\n    signature = :strip_namespace,\n    include = api -> api.hasdoc && !(api.value isa Module),\n)","category":"page"},{"location":"#ConcurrentUtils.jl","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"","category":"section"},{"location":"#Promise","page":"ConcurrentUtils.jl","title":"Promise","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        Promise,\n        try_race_fetch,\n        try_race_fetch_or!,\n        race_fetch_or!,\n        try_race_put!,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"Promise\ntry_race_fetch\ntry_race_fetch_or!\nrace_fetch_or!\ntry_race_put!","category":"page"},{"location":"#ConcurrentUtils.Promise","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.Promise","text":"Promise{T}()\nPromise()\n\nCreate a promise of type T; i.e., a memory location that holds a value of type T that can be set once and retrieved asynchronously.\n\nExtended help\n\nFor an explanation on the concept, see: Futures and promises - Wikipedia.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch(p)\nTry.Err: NotSetError()\n\njulia> put!(p, 123);\n\njulia> fetch(p)\n123\n\njulia> try_race_put!(p, 456)\nTry.Err: OccupiedError{Int64}(123)\n\nMemory ordering\n\nAn event that retrieves or waits for a value from a promise establishes a happened-before edge from the event that have set the value to the promise.  Invocations of the API that includes an event that sets a value to a promise include:\n\nput!(promise, value) that does not throw.\ntry_race_put!(promise, value) that returns an Ok result.\ntry_race_fetch_or!(thunk, promise) that calls thunk (and hance returns an Err).\nrace_fetch_or!(thunk, promise) that calls thunk.\n\n(The invocation thunk() is sequenced-before the event that sets the value.)\n\nInvocations of the API that includes an event that retrieves or waits for a value from a promise include:\n\nfetch(promise)\nwait(promise)\ntry_race_fetch(promise) that returns an Ok result.\ntry_race_fetch_or!(thunk, promise) that does not call thunk (and hance returns an Ok)\nrace_fetch_or!(thunk, promise) that does not call thunk\n\nSupported operations\n\nA promise::Promise{T} supports the following operations:\n\nput!(promise, value): Set a value; throws an error if some value has already been set.\ntry_race_put!(promise, value): Try to set a value.\nfetch(promise): Obtain a value that the promise holds. Wait if necessary.\nwait(promise): Wait for a value to be set.\ntry_race_fetch(promise): Try to obtain an existing value in the promise.\ntry_race_fetch_or!(thunk, promise): Try to get a value or set a value generated by thunk.\nrace_fetch_or!(thunk, promise): Similar to try_race_fetch_or! but  the returned value does not indicate if thunk is called or not.\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.try_race_fetch","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_fetch","text":"try_race_fetch(promiselike) -> Ok(value::T) or Err(NotSetError())\n\nTry to retrieve a value if it is already set.  Return Ok(value) on success and Err(NotSetError()) on failure.\n\ntry_race_fetch can be called on a Promise or a tasklet (@tasklet).\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch(p)\nTry.Err: NotSetError()\n\njulia> put!(p, 123);\n\njulia> try_race_fetch(p)\nTry.Ok: 123\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.try_race_fetch_or!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_fetch_or!","text":"try_race_fetch_or!(thunk, promise::Promise{T}) -> Ok(existing::T) or Err(computed::T)\n\nFetch an existing value or set a computed value (computed = thunk()).  The thunk is called at most once for each instance of promise.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_fetch_or!(p) do\n           123 + 456\n       end\nTry.Err: 579\n\njulia> try_race_fetch_or!(p) do\n           42\n       end\nTry.Ok: 579\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.race_fetch_or!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.race_fetch_or!","text":"race_fetch_or!(thunk, promise::Promise{T}) -> value::T\n\nFetch an existing value or set value = thunk().  The thunk is called at most once for each instance of promise.\n\nThis is similar to try_race_fetch_or! but the caller cannot tell if thunk is called or not by the return type.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> race_fetch_or!(p) do\n           println(\"called\")\n           123 + 456\n       end\ncalled\n579\n\njulia> race_fetch_or!(p) do\n           println(\"called\")\n           42\n       end\n579\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.try_race_put!","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_put!","text":"try_race_put!(promise::Promise{T}, value) -> Ok(value′::T) or Err(OccupiedError(existing::T))\n\nTry to set a value in the promise.\n\nSince the value is converted to T first, the returned value′ may not be identical to the input value.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> p = Promise{Int}();\n\njulia> try_race_put!(p, 123)\nTry.Ok: 123\n\njulia> try_race_put!(p, 456)\nTry.Err: OccupiedError{Int64}(123)\n\n\n\n\n\n","category":"function"},{"location":"#Promise-like-interfaces","page":"ConcurrentUtils.jl","title":"Promise-like interfaces","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        var\"@tasklet\",\n        var\"@once\",\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"@tasklet\n@once","category":"page"},{"location":"#ConcurrentUtils.@tasklet","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.@tasklet","text":"@tasklet code\n\nCreate an object that is a memoized version of () -> code but also acts like a Promise that is not settable.\n\nA t = @tasklet code supports: t(), fetch(t), wait(t), and try_race_fetch.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> t = @tasklet begin\n           println(\"called\")\n           123\n       end;\n\njulia> try_race_fetch(t)\nTry.Err: NotSetError()\n\njulia> t()\ncalled\n123\n\njulia> t()\n123\n\njulia> fetch(t)\n123\n\njulia> wait(t);\n\nMemory ordering\n\nAn event that retrieves or waits for a value from a tasklet t establishes a happened-before edge from the events in code.  Invocations of the API that includes an event that retrieves or waits for a value from a promise include:\n\nfetch(t)\nwait(t)\ntry_race_fetch(t) that returns an Ok result.\n\nSupported operations\n\nA tasklet t = @tasklet code supports the following operations:\n\nt(): Evaluate code if it hasn't been evaluated. Otherwise, equivalent to fetch.\nfetch(t): Wait for other tasks to invoke t() and then return the result.\nwait(t): Wait for other tasks to invoke t().\ntry_race_fetch: Try to retrieve the result of t() if it is already called.\n\n\n\n\n\n","category":"macro"},{"location":"#ConcurrentUtils.@once","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.@once","text":"@once code\n\nExecute code at most once within the lifetime of the Julia process.  It evaluates to the result of the first evaluation whenever the same location of the code is evaluated later.\n\nNote that code does not have access to the local variables.\n\nMemory ordering\n\nEvents that follow the run-time (as opposed to macro expansion-time) evaluation of @once code in the same Julia task have happened-before edge from the events in code.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> f() = @once Ref(123);\n\njulia> f() isa Ref\ntrue\n\njulia> f()[]\n123\n\nRef(123) is evaluated once and the identical Ref object is reused whenever f is called in this Julia process:\n\njulia> f() === f()\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"#Locks","page":"ConcurrentUtils.jl","title":"Locks","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        ReentrantCLHLock,\n        NonreentrantCLHLock,\n        ReentrantBackoffSpinLock,\n        NonreentrantBackoffSpinLock,\n        TaskObliviousLock,\n        read_write_lock,\n        acquire,\n        release,\n        try_race_acquire,\n        race_acquire,\n        acquire_then,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"ReentrantCLHLock\nNonreentrantCLHLock\nReentrantBackoffSpinLock\nNonreentrantBackoffSpinLock\nTaskObliviousLock\nread_write_lock\nacquire\nrelease\ntry_race_acquire\nrace_acquire\nacquire_then","category":"page"},{"location":"#ConcurrentUtils.ReentrantCLHLock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.ReentrantCLHLock","text":"ReentrantCLHLock\n\nA reentrant CLH \"spinnable\" lock that provides first-come-first-served fairness.  Keyword argument nspins::Integer can be passed to acquire to specify a number of spins tried before falling back to \"cooperative\" waiting in the Julia scheduler.\n\nExtended help\n\nReentrantCLHLock implements the spin lock by Craig (1993) and Magnussen, Landin, and Hagersten (1994) with a fallback to \"cooperatively\" wait in the scheduler instead of spinning (hence \"spinnable\").  See NonreentrantCLHLock that provides a non-reentrant version.\n\nMemory ordering\n\nA release invocation on a lock establishes happened-before edges to subsequent invocations of acquire and try_race_acquire that returns an Ok on the same lock.\n\nSupported operations\n\nacquire(lock::ReentrantCLHLock; [nspins::Integer]) (lock)\ntry_race_acquire(lock::ReentrantCLHLock) (trylock): Not very efficient but lock-free.  Fail with AcquiredByWriterError.\nrelease(lock::ReentrantCLHLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.NonreentrantCLHLock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.NonreentrantCLHLock","text":"NonreentrantCLHLock\n\nA (non-reentrant) CLH \"spinnable\" lock that provides first-come-first-served fairness. Keyword argument nspins::Integer can be passed to acquire to specify a number of spins tried before falling back to \"cooperative\" waiting in the Julia scheduler.\n\nExtended help\n\nNonreentrantCLHLock implements the spin lock by Craig (1993) and Magnussen, Landin, and Hagersten (1994) with a fallback to \"cooperatively\" wait in the scheduler instead of spinning (hence \"spinnable\").  See ReentrantCLHLock that provides a reentrant version.\n\nMemory ordering\n\nNonreentrantCLHLock has the same semantics as ReentrantCLHLock provided that each hand-off of the lock between tasks (if any) establishes a happened-before edge.\n\nSupported operations\n\nacquire(lock::NonreentrantCLHLock; [nspins::Integer]) (lock)\ntry_race_acquire(lock::NonreentrantCLHLock) (trylock): Not very efficient but lock-free.  Fail with AcquiredByWriterError.\nrelease(lock::NonreentrantCLHLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.ReentrantBackoffSpinLock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.ReentrantBackoffSpinLock","text":"ReentrantBackoffSpinLock\n\nA reentrant exponential backoff spin lock.\n\nSee also NonreentrantBackoffSpinLock that provides a non-reentrant version.\n\nExtended help\n\nMemory ordering\n\nA release invocation on a lock establishes happened-before edges to subsequent invocations of acquire and try_race_acquire that returns an Ok on the same lock.\n\nSupported operations\n\nReentrantBackoffSpinLock(; [mindelay], [maxdelay]) -> lock: Create a lock. mindelay (default: 1) specifies the number of spinloop called in the initial backoff.  mindelay (default: 1000) specifies the maximum backoff.\nacquire(lock::ReentrantBackoffSpinLock; [mindelay], [maxdelay]) (lock): Acquire the lock.  Keyword arguments mindelay and maxdelay can be passed to override the values specified by the constructor.\ntry_race_acquire(lock::ReentrantBackoffSpinLock) (trylock):\nrelease(lock::ReentrantBackoffSpinLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.NonreentrantBackoffSpinLock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.NonreentrantBackoffSpinLock","text":"NonreentrantBackoffSpinLock\n\nA non-reentrant exponential backoff spin lock.\n\nSee also ReentrantBackoffSpinLock that provides a reentrant version.\n\nExtended help\n\nNonreentrantBackoffSpinLock performs better than Base.Threads.SpinLock with high contention.  NonreentrantCLHLock is better than NonreentrantBackoffSpinLock with high contention with many worker threads (20 to 80; it depends on the machine).\n\nSince NonreentrantBackoffSpinLock does not have a fallback \"cooperative\" waiting mechanism, NonreentrantCLHLock is in general recommended.\n\nMemory ordering\n\nNonreentrantBackoffSpinLock has the same semantics as ReentrantBackoffSpinLock provided that each hand-off of the lock between tasks (if any) establishes a happened-before edge.\n\nSupported operations\n\nNonreentrantBackoffSpinLock(; [mindelay], [maxdelay]) -> lock: Create a lock. mindelay (default: 1) specifies the number of spinloop called in the initial backoff.  mindelay (default: 1000) specifies the maximum backoff.\nacquire(lock::NonreentrantBackoffSpinLock; [mindelay], [maxdelay]) (lock): Acquire the lock.  Keyword arguments mindelay and maxdelay can be passed to override the values specified by the constructor.\ntry_race_acquire(lock::NonreentrantBackoffSpinLock) (trylock):\nrelease(lock::NonreentrantBackoffSpinLock) (unlock)\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.TaskObliviousLock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.TaskObliviousLock","text":"TaskObliviousLock\n\nA lock that can be released in a task that did not acquire the lock.  It does not support reentrancy.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> lock = TaskObliviousLock();\n\njulia> acquire(lock);\n\njulia> wait(Threads.@spawn release(lock));  # completes\n\nSupported operations\n\nacquire(lock::TaskObliviousLock) (lock)\nrelease(lock::TaskObliviousLock) (unlock)\n\nImplementation detail\n\nTaskObliviousLock is an alias to unspecified implementation of lock.  Currently, it is:\n\njulia> TaskObliviousLock === NonreentrantCLHLock\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.read_write_lock","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.read_write_lock","text":"read_write_lock() -> (rlock, wlock)\n\nReturn the read handle rlock and the write handle wlock of a read-write lock.\n\nExtended help\n\nSupported operations:\n\nacquire(rlock) (lock)\ntry_race_acquire(rlock; [nspins], [ntries]) (trylock): Not very efficient but lock-free.  Fail with TooManyTries.\nrelease(rlock) (unlock)\nacquire(wlock) (lock)\ntry_race_acquire(wlock) (trylock): Fail with NotAcquirableError.\nrelease(wlock) (unlock)\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.acquire","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.acquire","text":"acquire(lock)\n\nAcquire a lock.  It is equivalent to Base.lock(lock) but it may support additional keyword arguments.\n\nSee also release and try_race_acquire.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> lock = ReentrantCLHLock();\n\njulia> acquire(lock);\n\njulia> release(lock);\n\nOn naming\n\nConcurrentUtils.jl uses acquire/release instead of lock/unlock so that:\n\nVariable lock can be used.\nMake it clear that ConcurrentUtils.try_race_acquire(lock) -> result::Union{Ok,Err} and Base.trylock(lock) -> locked::Bool have different return types.  In particular, try_race_acquire can report the reason why certain attempt have failed.\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.release","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.release","text":"release(lock)\n\nRelease a lock.  It is equivalent to Base.unlock(lock).\n\nSee also acquire and try_race_acquire.\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.try_race_acquire","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.try_race_acquire","text":"try_race_acquire(lock) -> Ok(nothing) or Err(reason)\n\nTry to acquire lock and return Ok(nothing) on success.  Return an Err wrapping a value explaining a reason of failure.\n\nSee the documentation of typeof(lock) for possible error types.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> lock = NonreentrantCLHLock();\n\njulia> try_race_acquire(lock)\nTry.Ok: nothing\n\njulia> try_race_acquire(lock)\nTry.Err: TooManyTries(0, 0)\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.race_acquire","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.race_acquire","text":"race_acquire(lock) -> isacquired::Bool\n\nTry to acquire lock and return true on success and false on failure.\n\nSee also try_race_acquire.\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> lock = NonreentrantCLHLock();\n\njulia> race_acquire(lock)\ntrue\n\njulia> race_acquire(lock)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"#ConcurrentUtils.acquire_then","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.acquire_then","text":"acquire_then(f, lock; acquire_options...) -> y\n\nExecute a thunk f in a critical section protected by lock and return the value y returned from f.  Keyword arguments are passed to acquire.\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> lock = ReentrantCLHLock();\n\njulia> acquire_then(lock; nspins = 10) do\n           123 + 456\n       end\n579\n\n\n\n\n\n","category":"function"},{"location":"#Low-level-interfaces","page":"ConcurrentUtils.jl","title":"Low-level interfaces","text":"","category":"section"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"using DocumentationOverview\nusing ConcurrentUtils\nDocumentationOverview.table_md(\n    :[\n        ThreadLocalStorage,\n        spinloop,\n    ],\n    namespace = ConcurrentUtils,\n    signature = :name,\n)","category":"page"},{"location":"","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.jl","text":"ThreadLocalStorage\nspinloop","category":"page"},{"location":"#ConcurrentUtils.ThreadLocalStorage","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.ThreadLocalStorage","text":"ThreadLocalStorage{T}(factory)\nThreadLocalStorage(factory)\n\nCreate a thread-local storage of type T created by factory().\n\nAn instance tls of ThreadLocalStorage support the operation x = tls[] for obtaining an object x of value T.\n\nwarning: Warning\nUsing this API is extremely tricky.  Arguably, it is not even well-defined when and how it can be used.Theoretically, it is safe to use this API if the programmer can ensure that, once a value x = tls[] is obtained, the code does not hit any yield points until there is no more access to x.  However, it is not possible to know if a certain operation is yield-free in general.Thus, this API currently exists primarily for helping migration of code written using nthreads and threadid in an ad-hoc manner.\n\nAn object of type T is allocated for each worker thread of the Julia runtime.  If T is not given, T = typeof(factory()) is used (i.e., factory is assumed to be type-stable).\n\nExtended help\n\nExamples\n\njulia> using ConcurrentUtils\n\njulia> tls = ThreadLocalStorage(Ref{Int});\n\njulia> tls[] isa Ref{Int}\ntrue\n\njulia> tls[][] = 123;\n\njulia> tls[][]\n123\n\n\n\n\n\n","category":"type"},{"location":"#ConcurrentUtils.spinloop","page":"ConcurrentUtils.jl","title":"ConcurrentUtils.spinloop","text":"spinloop()\n\nA hint to the compiler, runtime, and hardware that spinloop() is in the middle of a spin loop.  Call this in a spin loop that requires some other worker threads to make forward progress in order for the current thread to make forward progress.\n\nwarning: Warning\nObserve that the above sentence specifically mentions worker threads and not Tasks.  A Julia programmer should always be alarmed whenever an API talks about threads instead of Tasks.  Prefer higher-level APIs such as channels and condition variables.A proper use of spinloop requires extra cares such as a fallback that waits in the Julia scheduler and/or a mechanism that enables the spin loop code path given that other threads exist and a task that can break the spin loop is running or will be scheduled eventually.\n\nImplementation detail\n\nIt calls GC.safepoint() and jl_cpu_pause.\n\n\n\n\n\n","category":"function"}]
}
